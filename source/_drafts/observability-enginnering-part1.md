---
title: observability-enginnering-part1
tags:
---


### 第一章：什麼是可觀測性
Kalman 論文中提到，從系統外部輸出中推斷其內部狀態的能力。
1. 理解 Process 的內部運作
2. 理解 Process 的任何狀態
3. 只需透過觀察就能了解內部運作和系統狀態
文章中提到將可觀測性套用到系統上，就能夠解釋任何異常狀態、找到細微效能異常、迅速定位問題發生的原因
不需要發布新程式碼就能夠滿足上面情境，就可以稱系統具有可觀測性

高維度 (資料的欄位數量，可以有更多資訊的排列組合)、高基數 (高比例不同的值，對於定位問題相當有幫助)資料是發現複雜系統架構中潛在問題的關鍵

### 第二章 可觀測性與監控的 Debug 有什麼不同
監控通常就是我們看到的 CPU, API Request Time 等等顯示在儀表板的資料，使用監控來進行除錯很常需要工程師對於系統熟悉而產生的直覺，隨著系統複雜度的提高很容易遇到人類的極限
可觀測性可以藉由提高維度跟基數的資料組合定位出問題點，可觀測性的好處就是不再仰賴在最有商業邏輯經驗的工程師。

### 第三章 沒有可觀測性的擴展教訓

英雄文化是不推薦的。

### 第四章 可觀測性與 DevOps, SRE 和 Cloud Native 的關聯

Cloud Native 與過去舊有架構相比更加複雜，有經驗的 SRE 團隊應該要症狀監控，列出可能導致故障的原因清單在透過可觀測工具去量測使用者痛點。

### 第五章 結構化事件是可觀測性的基礎

**結構化事件 (log)**：事件是單一服務在請求服務互動時發生的事情，並用 Key-Value 或 Json 方式紀錄相關細節 (結構化)
相比與傳統性的 Log 只是流水帳而且有大量雜訊的資料會讓工程師在查找問題時需要有對系統有一定的熟悉度

指標的問題是一段時間的聚合，這樣有可能會掩飾掉某些細節

### 第六章 將事件串連成追蹤

**分散式追蹤**，追蹤單個請求在各個服務之間處理的狀況，追蹤會用 Span (跨度) 表示其執行時間，要組成這樣的關係需要以下資訊
1. `Trace ID`：用來追蹤一個特定請求的所有流程，讓其可以被認知到是在同一個流程
2. `Span ID`：單一 Span 的 ID
3. `Parent ID`：其呼叫的父 `Span ID`
4. `Timestamp`：`Span` 開始時間
5. `Duration`：每個 `Sapn` 的所需時間

![alt text](span.png)


### 第七章 使用 OpenTelemetry 檢測